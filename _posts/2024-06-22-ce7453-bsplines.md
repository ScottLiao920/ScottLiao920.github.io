---
title: 'CE7453: B-splines'
date: 2024-06-22
permalink: /posts/2024/06/ce7453-bsplines/
tags:
  - CE7453
  - B-splines
  - NURBS
  - computer graphics
  - geometric modeling
  - exam preparation
---

This post summarizes key concepts of B-splines covered in CE7453, based on the lecture notes "04-Bsplines".

## Key Concepts

B-splines (Basis splines) extend Bezier curves to address limitations such as local control while maintaining the powerful mathematical properties. They form the foundation for modern computer-aided geometric design.

### Historical Development

B-splines were developed in the 1970s to overcome the limitations of Bezier curves, particularly the lack of local control and the need for high-degree curves to represent complex shapes. The mathematical foundation of B-splines traces back to I.J. Schoenberg's work in the 1940s, with significant contributions from Carl de Boor in the 1970s.

### Real-world Applications

- **CAD/CAM Systems**: Industry standard for precision modeling in manufacturing
- **Animation**: Character rigging and smooth motion in film and games
- **Font Design**: TrueType fonts use B-spline representations
- **Medical Imaging**: Representing anatomical structures
- **Aerospace Design**: Aircraft and spacecraft component modeling

## B-spline Fundamentals

### 1. Knot Vector

- **Definition**: A non-decreasing sequence of parameter values T = {t₀, t₁, ..., t<sub>m</sub>}
- **Types**:
  - **Uniform**: Knots are equally spaced
  - **Non-uniform**: Knots may have irregular spacing
  - **Open/Clamped**: End knots have multiplicity equal to order (k)
- **Multiplicity**: Repeated knot values affect continuity

#### Knot Vector Construction

For a B-spline of degree p with n+1 control points, the knot vector needs m+1 knots where m = n+p+1. The knot vector can be constructed in different ways:

**Uniform Knot Vector**:
- Equally spaced knots: T = {0, 1, 2, 3, ...}
- Often normalized to [0,1]: T = {0, 0.25, 0.5, 0.75, 1}

**Open (Clamped) Uniform Knot Vector**:
- First p+1 knots equal the first parameter value
- Last p+1 knots equal the last parameter value
- For p=3 (cubic): T = {0, 0, 0, 0, 0.25, 0.5, 0.75, 1, 1, 1, 1}

**Non-uniform Knot Vector**:
- Unequally spaced knots allowing more flexibility
- Example: T = {0, 0, 0, 0.1, 0.3, 0.7, 0.9, 1, 1, 1}

#### Knot Span and Parameter Range

For a knot vector T = {t₀, t₁, ..., t<sub>m</sub>}, the B-spline is typically defined over the parameter range [t<sub>p</sub>, t<sub>m-p</sub>], where p is the degree. This is the region where complete basis functions are defined.

#### Worked Example: Knot Vector Analysis

Consider a cubic B-spline (p=3) with 7 control points (n=6). We need m+1 = n+p+1+1 = 11 knots.

For an open uniform knot vector:
T = {0, 0, 0, 0, 0.25, 0.5, 0.75, 1, 1, 1, 1}

- Valid parameter range: [t<sub>p</sub>, t<sub>m-p</sub>] = [t<sub>3</sub>, t<sub>7</sub>] = [0, 1]
- Knot spans: [0, 0.25], [0.25, 0.5], [0.5, 0.75], [0.75, 1]

### 2. Basis Functions

- **Recursive Definition**:
  - N<sub>i,1</sub>(t) = 1 if t<sub>i</sub> ≤ t < t<sub>i+1</sub>, 0 otherwise
  - N<sub>i,k</sub>(t) = ((t-t<sub>i</sub>)/(t<sub>i+k-1</sub>-t<sub>i</sub>))N<sub>i,k-1</sub>(t) + ((t<sub>i+k</sub>-t)/(t<sub>i+k</sub>-t<sub>i+1</sub>))N<sub>i+1,k-1</sub>(t)
- **Properties**:
  - Local support: N<sub>i,k</sub>(t) = 0 for t outside [t<sub>i</sub>, t<sub>i+k</sub>]
  - Non-negative: N<sub>i,k</sub>(t) ≥ 0
  - Partition of unity: Σ<sub>i</sub> N<sub>i,k</sub>(t) = 1
  - C<sup>k-p-1</sup> continuity at a knot with multiplicity p

#### Deriving B-spline Basis Functions

Let's trace through the recursive calculation for cubic (k=4) basis functions with the uniform knot vector T = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}:

**First-degree basis (k=1)**:
- N<sub>3,1</sub>(t) = 1 if 3 ≤ t < 4, 0 otherwise
- N<sub>4,1</sub>(t) = 1 if 4 ≤ t < 5, 0 otherwise
- N<sub>5,1</sub>(t) = 1 if 5 ≤ t < 6, 0 otherwise

**Second-degree basis (k=2)**:
- N<sub>3,2</sub>(t) = ((t-3)/(4-3))N<sub>3,1</sub>(t) + ((5-t)/(5-4))N<sub>4,1</sub>(t)
  = (t-3)N<sub>3,1</sub>(t) + (5-t)N<sub>4,1</sub>(t)
- N<sub>4,2</sub>(t) = ((t-4)/(5-4))N<sub>4,1</sub>(t) + ((6-t)/(6-5))N<sub>5,1</sub>(t)
  = (t-4)N<sub>4,1</sub>(t) + (6-t)N<sub>5,1</sub>(t)

**Third-degree basis (k=3)**:
- N<sub>3,3</sub>(t) = ((t-3)/(5-3))N<sub>3,2</sub>(t) + ((6-t)/(6-4))N<sub>4,2</sub>(t)
  = ((t-3)/2)N<sub>3,2</sub>(t) + ((6-t)/2)N<sub>4,2</sub>(t)

**Fourth-degree basis (k=4, cubic)**:
- N<sub>3,4</sub>(t) = ((t-3)/(6-3))N<sub>3,3</sub>(t) + ((7-t)/(7-4))N<sub>4,3</sub>(t)
  = ((t-3)/3)N<sub>3,3</sub>(t) + ((7-t)/3)N<sub>4,3</sub>(t)

#### Visualization of Basis Functions

For a cubic B-spline with uniform knot vector:
- Each N<sub>i,4</sub>(t) is non-zero only over 4 knot spans [t<sub>i</sub>, t<sub>i+4</sub>]
- At any parameter t, exactly p+1 (4) basis functions are non-zero
- The shape resembles a bell curve, with C² continuity across spans

#### Python Implementation: B-spline Basis Functions
```python
import numpy as np

def basis_function(i, k, t, knots):
    """
    Evaluate the B-spline basis function N_i,k at parameter t.
    
    Parameters:
    - i: Index of the control point
    - k: Degree of the basis function
    - t: Parameter value
    - knots: Knot vector
    
    Returns:
    - Value of the basis function
    """
    # Base case for degree 1
    if k == 1:
        if knots[i] <= t < knots[i+1] or (t == knots[-1] and knots[i] <= t <= knots[i+1]):
            return 1.0
        return 0.0
    
    # Recursive case
    d1 = 0.0
    if knots[i+k-1] - knots[i] != 0:  # Avoid division by zero
        d1 = (t - knots[i]) / (knots[i+k-1] - knots[i]) * basis_function(i, k-1, t, knots)
    
    d2 = 0.0
    if knots[i+k] - knots[i+1] != 0:  # Avoid division by zero
        d2 = (knots[i+k] - t) / (knots[i+k] - knots[i+1]) * basis_function(i+1, k-1, t, knots)
    
    return d1 + d2
```

### 3. B-spline Curves

- **Equation**: P(t) = Σ<sub>i=0</sub><sup>n</sup> P<sub>i</sub> N<sub>i,k</sub>(t)
- **Properties**:
  - Local modification: Moving a control point affects only k spans
  - Endpoint interpolation (for clamped knot vectors)
  - Affine invariance
  - Variation diminishing

#### Local Control Property

One of the key advantages of B-splines over Bezier curves is local control:
- Moving control point P<sub>i</sub> only affects the curve in the parameter range [t<sub>i</sub>, t<sub>i+k</sub>]
- This allows designers to make local adjustments without affecting the entire curve

#### Worked Example: Cubic B-spline Curve Evaluation

Consider a cubic B-spline (k=4) with control points P₀ = (0,0), P₁ = (1,2), P₂ = (3,3), P₃ = (5,0), P₄ = (6,2) and the knot vector T = {0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4}.

To evaluate the curve at t = 1.5:
1. Find which basis functions are non-zero at t = 1.5: N<sub>1,4</sub>, N<sub>2,4</sub>, N<sub>3,4</sub>, N<sub>4,4</sub>
2. Calculate their values:
   - N<sub>1,4</sub>(1.5) ≈ 0.125
   - N<sub>2,4</sub>(1.5) ≈ 0.458
   - N<sub>3,4</sub>(1.5) ≈ 0.375
   - N<sub>4,4</sub>(1.5) ≈ 0.042
3. Compute the point on the curve:
   P(1.5) = 0.125P₁ + 0.458P₂ + 0.375P₃ + 0.042P₄
   = 0.125(1,2) + 0.458(3,3) + 0.375(5,0) + 0.042(6,2)
   = (3.71, 1.67)

#### Python Implementation: B-spline Curve
```python
def bspline_curve_point(t, control_points, knots, degree):
    """
    Evaluate a B-spline curve at parameter t.
    
    Parameters:
    - t: Parameter value
    - control_points: Array of control points
    - knots: Knot vector
    - degree: Degree of the B-spline
    
    Returns:
    - Point on the B-spline curve
    """
    n = len(control_points) - 1
    point = np.zeros_like(control_points[0]).astype(float)
    
    # Find index of knot span containing t
    span = find_span(t, knots)
    
    # Calculate basis functions
    for i in range(span - degree, span + 1):
        if 0 <= i <= n:
            basis_val = basis_function(i, degree + 1, t, knots)
            point += control_points[i] * basis_val
    
    return point

def find_span(t, knots):
    """Find the knot span index."""
    n = len(knots) - 1
    # Special case for t at the upper end
    if t >= knots[n]:
        return n - 1
    
    # Binary search
    low, high = 0, n
    mid = (low + high) // 2
    
    while t < knots[mid] or t >= knots[mid + 1]:
        if t < knots[mid]:
            high = mid
        else:
            low = mid
        mid = (low + high) // 2
    
    return mid
```

## Advanced B-spline Topics

### 1. De Boor Algorithm

- **Purpose**: Analogous to De Casteljau for B-splines
- **Process**: Recursive evaluation based on knot spans
- **Efficiency**: Numerically stable evaluation method

#### De Boor Algorithm Steps

For a B-spline of degree p with knot vector T and parameter t in span [t<sub>k</sub>, t<sub>k+1</sub>):

1. Initialize: Set d<sub>i,0</sub> = P<sub>i-p+r</sub> for i = k-p, ..., k, where r is the multiplicity of t
2. For j = 1 to p-r:
   - For i = k, ..., k-p+j:
     - α<sub>i,j</sub> = (t - t<sub>i</sub>)/(t<sub>i+p-j+1</sub> - t<sub>i</sub>)
     - d<sub>i,j</sub> = (1-α<sub>i,j</sub>)d<sub>i-1,j-1</sub> + α<sub>i,j</sub>d<sub>i,j-1</sub>
3. The point on the curve is d<sub>k,p-r</sub>

#### Python Implementation: De Boor Algorithm
```python
def de_boor(t, control_points, knots, degree):
    """
    Evaluate B-spline curve at parameter t using De Boor algorithm.
    
    Parameters:
    - t: Parameter value
    - control_points: Array of control points
    - knots: Knot vector
    - degree: Degree of the B-spline
    
    Returns:
    - Point on the B-spline curve
    """
    # Find knot span
    span = find_span(t, knots)
    
    # Special case: t is at a knot
    if t == knots[span]:
        # Handle multiplicity (simplified for this example)
        return control_points[span - degree]
    
    # Initialize d array
    d = [control_points[i] for i in range(span - degree, span + 1)]
    
    # Apply De Boor recursion
    for r in range(1, degree + 1):
        for j in range(degree, r - 1, -1):
            i = span - degree + j
            alpha = (t - knots[i]) / (knots[i + degree - r + 1] - knots[i])
            d[j] = (1.0 - alpha) * d[j - 1] + alpha * d[j]
    
    return d[degree]
```

### 2. Knot Insertion

- **Purpose**: Add knots without changing curve shape
- **Applications**: 
  - Refinement for analysis
  - Splitting curves
  - Converting to Bezier representation

#### Knot Insertion Algorithm

To insert a knot t̄ into knot vector T (between t<sub>k</sub> and t<sub>k+1</sub>):

1. New knot vector: T' = {t₀, t₁, ..., t<sub>k</sub>, t̄, t<sub>k+1</sub>, ..., t<sub>m</sub>}
2. New control points:
   P<sub>i</sub>' = αᵢP<sub>i</sub> + (1-αᵢ)P<sub>i-1</sub> for i = k-p+1, ..., k
   where:
   - αᵢ = (t̄ - t<sub>i</sub>)/(t<sub>i+p</sub> - t<sub>i</sub>) if i ∈ [k-p+1, k]
   - αᵢ = 1 if i > k
   - αᵢ = 0 if i < k-p+1
3. Original control points outside the range [k-p+1, k] remain unchanged

#### Bezier Decomposition

By inserting knots of multiplicity p at each interior knot, a B-spline can be converted into a series of Bezier curves. This is useful for rendering and intersection algorithms.

### 3. Degree Elevation

- **Process**: Increase degree while preserving shape
- **Application**: Compatibility between curves of different degrees

#### Degree Elevation Algorithm

To increase the degree of a B-spline from p to p+1:

1. Create a new knot vector by adding duplicates of each knot
2. Calculate new control points through a linear combination of original points
3. Preserve the shape of the original curve

### 4. Non-Uniform Rational B-splines (NURBS)

- **Definition**: Rational extension of B-splines
- **Equation**: P(t) = Σ<sub>i=0</sub><sup>n</sup> w<sub>i</sub>P<sub>i</sub> N<sub>i,k</sub>(t) / Σ<sub>i=0</sub><sup>n</sup> w<sub>i</sub> N<sub>i,k</sub>(t)
- **Advantages**:
  - Exact representation of conic sections
  - Perspective invariance
  - Extended modeling capabilities

#### NURBS Formulation

NURBS extend B-splines by associating a weight w<sub>i</sub> with each control point P<sub>i</sub>. The rational basis functions are:

R<sub>i,p</sub>(t) = w<sub>i</sub>N<sub>i,p</sub>(t) / Σ<sub>j=0</sub><sup>n</sup> w<sub>j</sub>N<sub>j,p</sub>(t)

The NURBS curve is then:
P(t) = Σ<sub>i=0</sub><sup>n</sup> P<sub>i</sub>R<sub>i,p</sub>(t)

#### Representing Conic Sections

NURBS can exactly represent circles, ellipses, and other conic sections:

**Circle**: With degree p=2, n+1=9 control points, and weights:
- P₀, P₂, P₄, P₆, P₈ on the circle with w=1
- P₁, P₃, P₅, P₇ at intersections of tangent lines with w=cos(π/4) = 1/√2 ≈ 0.7071

#### Python Implementation: NURBS Curve
```python
def nurbs_curve_point(t, control_points, weights, knots, degree):
    """
    Evaluate a NURBS curve at parameter t.
    
    Parameters:
    - t: Parameter value
    - control_points: Array of control points
    - weights: Array of weights
    - knots: Knot vector
    - degree: Degree of the NURBS
    
    Returns:
    - Point on the NURBS curve
    """
    n = len(control_points) - 1
    
    num = np.zeros_like(control_points[0]).astype(float)
    den = 0.0
    
    # Find the span and calculate basis functions
    span = find_span(t, knots)
    
    for i in range(span - degree, span + 1):
        if 0 <= i <= n:
            basis_val = basis_function(i, degree + 1, t, knots)
            weight_basis = weights[i] * basis_val
            num += control_points[i] * weight_basis
            den += weight_basis
    
    return num / den if den != 0 else num
```

## Applications

- **CAD/CAM**: Industry standard for representing curves and surfaces
- **Animation**: Control of smooth motion paths
- **Font Design**: TrueType fonts use B-splines
- **Image Processing**: Representing contours and geometric features
- **FEA**: Isogeometric analysis based on NURBS

### B-splines in CAD/CAM

Modern CAD systems like CATIA, SolidWorks, and AutoCAD use NURBS as their underlying representation for curves and surfaces. This provides:
- Precise control over complex geometries
- Compact mathematical representation
- Efficient evaluation for rendering and analysis
- Preservation of design intent during editing

### Isogeometric Analysis

This advanced technique unifies CAD and finite element analysis by using the same NURBS basis functions for both geometry representation and analysis, eliminating the need for geometry approximation through meshing.

## Comparison with Bezier Curves

- **Local Control**: B-splines offer local control
- **Continuity**: Automatic higher-order continuity between segments
- **Flexibility**: Variable degree and knot placement
- **Complexity**: More parameters to control (knot vector, weights)

### Side-by-Side Comparison

| Feature | Bezier Curves | B-splines |
|---------|---------------|-----------|
| Local Control | No | Yes |
| Number of Control Points | Fixed by degree | Independent of degree |
| Continuity Between Segments | Requires constraints | Automatic |
| Exact Representation of Circle | No | Yes (with NURBS) |
| Implementation Complexity | Simpler | More complex |
| Degree | Same as number of control points - 1 | Independent parameter |

## Exam Focus Areas

1. **Basis Function Calculation**: Recursive calculation of basis functions
2. **Knot Vector Design**: Understand effects of different knot vectors
3. **De Boor Algorithm**: Implementation and application
4. **Continuity Analysis**: Determining continuity at knots
5. **NURBS Understanding**: Basic principles and advantages

### Sample Exam Questions

1. Calculate the non-zero basis functions at a specific parameter value.
2. Determine the minimum degree required for specific continuity conditions.
3. Explain how knot multiplicity affects the curve's continuity.
4. Convert a B-spline representation to a Bezier representation.
5. Design a B-spline to interpolate a set of points with specific continuity.

## Practice Problems

1. Calculate B-spline basis functions for a given knot vector
2. Implement the De Boor algorithm for curve evaluation
3. Determine the effect of knot insertion on a B-spline curve
4. Convert a B-spline curve to a set of Bezier curves

### Challenge Problem

Design a cubic B-spline curve that interpolates the points (0,0), (2,4), (5,1), and (8,3) with C² continuity everywhere. Determine the appropriate knot vector and control points.

**Solution Approach**:
1. Set up an interpolation matrix using the B-spline basis functions
2. Solve the linear system to find control points
3. Verify continuity conditions at the interpolation points

Original lecture notes are available at: `/files/CE7453/CE7453/04-Bsplines-4slides1page(1).pdf` 